/**
 * Core Philosophy: This ruleset enforces a strict, user-centric security model. Data is segregated into three primary categories:
 * 1. Private User Data: Information exclusively owned and managed by a single user (e.g., profiles, emergency contacts).
 * 2. Collaborative Data: Resources shared among a defined group of users (e.g., teams).
 * 3. Public Data: Information accessible to anyone, but writable only under specific conditions (e.g., job posts, learning materials).
 *
 * Data Structure:
 * - User-specific data is nested under the `/users/{userId}` path, creating a clear ownership boundary.
 * - Collaborative data, like `/teams/{teamId}`, is stored at the top level.
 * - Publicly readable content, such as `/job_posts` and `/learning_modules`, is also at the top level for easy querying.
 *
 * Key Security Decisions:
 * - Default Deny: All paths are closed by default. Access is granted explicitly.
 * - No User Listing: The top-level `/users` collection is not listable to protect user privacy.
 * - No Public Team Listing: The `/teams` collection is not listable to prevent discovery of private groups.
 * - Denormalization for Authorization: Collaborative documents like `/teams/{teamId}` contain a `memberIds` array and an `ownerId` field directly on the document. This avoids slow and costly `get()` calls in rules, ensuring fast and secure authorization checks. For public content like `/job_posts`, an `employerId` is denormalized onto the document to manage write permissions.
 * - Prototyping Flexibility: Data shapes are not strictly validated. Rules focus solely on authorization (who can do what) and relational integrity (e.g., ensuring a `userId` in a subcollection document matches the `userId` in the path), allowing the application schema to evolve without constant rule changes.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // --------------------------------------------------------------------
    // Helper Functions
    // --------------------------------------------------------------------

    /**
     * Checks if the user is authenticated.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * Checks if the authenticated user's UID matches the provided userId.
     * This is the primary function for enforcing document ownership.
     */
    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    /**
     * Verifies that a document already exists.
     * CRITICAL for all update and delete operations to prevent acting on non-existent data.
     */
    function isExistingDoc() {
      return resource != null;
    }

    /**
     * Combines ownership check with an existence check.
     * Used for safe updates and deletes on user-owned documents.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && isExistingDoc();
    }

    /**
     * Checks if the authenticated user is the owner of a team.
     * Ownership is determined by the `ownerId` field on the team document.
     */
    function isTeamOwner() {
      return isSignedIn() && isExistingDoc() && request.auth.uid == resource.data.ownerId;
    }

    /**
     * Checks if the authenticated user is a member of a team.
     * Membership is determined by the `memberIds` array on the team document.
     */
    function isTeamMember() {
      return isSignedIn() && isExistingDoc() && request.auth.uid in resource.data.memberIds;
    }

    /**
     * Checks if the authenticated user is the creator of a job post.
     * Authorship is determined by the `employerId` field on the job post document.
     */
    function isJobPostCreator() {
      return isSignedIn() && isExistingDoc() && request.auth.uid == resource.data.employerId;
    }


    // --------------------------------------------------------------------
    // User Profile Rules (/users)
    // --------------------------------------------------------------------

    /**
     * @description Controls access to a user's own profile document.
     * @path /users/{userId}
     * @allow A signed-in user (create)s their own profile document, where the document ID matches their UID.
     * @deny An anonymous user tries to (get) a user profile.
     * @deny A signed-in user tries to (update) another user's profile.
     * @principle Enforces strict user ownership. Users can only manage their own profile document.
     */
    match /users/{userId} {
      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    // --------------------------------------------------------------------
    // User Learning Progress Rules (/users/{userId}/learning_progress)
    // --------------------------------------------------------------------

    /**
     * @description Manages a user's private learning progress records.
     * @path /users/{userId}/learning_progress/{learningProgressId}
     * @allow A user (create)s a new progress record under their own user path.
     * @allow The same user (list)s all of their progress records.
     * @deny A user attempts to (get) or (list) the learning progress of another user.
     * @principle Restricts access to a user's own data tree, enforcing privacy for personal progress.
     */
    match /users/{userId}/learning_progress/{learningProgressId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    // --------------------------------------------------------------------
    // User Emergency Contacts Rules (/users/{userId}/emergency_contacts)
    // --------------------------------------------------------------------

    /**
     * @description Secures a user's private emergency contact information.
     * @path /users/{userId}/emergency_contacts/{contactId}
     * @allow A user (delete)s an emergency contact from their own profile.
     * @allow The same user (list)s all of their own emergency contacts.
     * @deny A user tries to (create) an emergency contact for another user.
     * @principle Restricts access to a user's own data tree, protecting sensitive personal information.
     */
    match /users/{userId}/emergency_contacts/{contactId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.userId == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.userId == resource.data.userId;
      allow delete: if isExistingOwner(userId);
    }

    // --------------------------------------------------------------------
    // Job Post Rules (/job_posts)
    // --------------------------------------------------------------------

    /**
     * @description Defines access for public job postings.
     * @path /job_posts/{jobPostId}
     * @allow Any user, including anonymous ones, can (get) or (list) job posts.
     * @allow A signed-in user (create)s a new job post, setting the `employerId` to their own UID.
     * @allow The original employer (update)s their own job post.
     * @deny A user tries to (update) or (delete) a job post created by someone else.
     * @principle Implements a "Public Read, Owner-Only Write" model.
     */
    match /job_posts/{jobPostId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.employerId == request.auth.uid;
      allow update: if isJobPostCreator();
      allow delete: if isJobPostCreator();
    }

    // --------------------------------------------------------------------
    // Learning Module Rules (/learning_modules)
    // --------------------------------------------------------------------

    /**
     * @description Manages publicly available learning content.
     * @path /learning_modules/{learningModuleId}
     * @allow Any user, signed-in or anonymous, can (get) or (list) learning modules.
     * @deny All write operations ((create), (update), (delete)) are denied from the client.
     * @principle Defines a read-only public data collection. Content should be managed via the Admin SDK.
     */
    match /learning_modules/{learningModuleId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    // --------------------------------------------------------------------
    // Team Rules (/teams)
    // --------------------------------------------------------------------

    /**
     * @description Secures collaborative teams. Access is granted to team members and owners.
     * @path /teams/{teamId}
     * @allow A user who is in the `memberIds` array can (get) the team document.
     * @allow The user designated as the `ownerId` can (update) or (delete) the team.
     * @deny The entire `/teams` collection cannot be listed to prevent discovery of private teams.
     * @deny A non-member tries to (get) team data.
     * @principle Implements a "Shared Access (Closed Collaborators)" model using denormalized member lists.
     */
    match /teams/{teamId} {
      allow get: if isTeamMember();
      allow list: if false;
      allow create: if isSignedIn() && request.resource.data.ownerId == request.auth.uid && request.auth.uid in request.resource.data.memberIds;
      allow update: if isTeamOwner() && request.resource.data.ownerId == resource.data.ownerId;
      allow delete: if isTeamOwner();
    }

  }
}